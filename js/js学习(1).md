title: js学习(1)
date: 2016-04-05 12:05:05
tags:
- js

# js学习(1)
---
没有系统学习过js，觉得基础太薄弱了，参考阮一峰老师的[JavaScript 标准参考教程](http://javascript.ruanyifeng.com/)，希望可以提高自己js的基础。

# 2. 基本语法
------

# 基本句法和变量

### 语句

**语句（statement）**是为了完成某种任务而进行的操作

	var a = 1 + 3;

**表达式（expression）**为了得到返回值的计算式。

	1 + 3

> 语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。

* 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。
* 表达式不需要分号结尾。一旦在表达式后面添加分号，则JavaScript引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。

### 变量

	var a;
	a = 1;
	var a = 1;

* 变量是对“值”的引用，使用变量等同于引用一个值。
* 变量的声明和赋值，是分开的两个步骤。但是可以合起来一起写。
* 只是声明变量而没有赋值，则该变量的值是不存在的，JavaScript使用`undefined`表示这种情况。
* 没有声明就直接使用，JavaScript会报错，告诉你变量未定义

#### 变量提升

JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做**变量提升（hoisting）**

	console.log(a); // undefined
	var a = 1;
	
	==>
	
	var a;
	console.log(a);  // undefined
	a = 1;

变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。

### 标识符

* 第一个字符，可以是任意Unicode字母，以及美元符号（$）和下划线（_）。
* 第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字0-9。
* JavaScript有一些保留字，不能用作标识符
* 不应该用作标识符：`Infinity`、`NaN`、`undefined`

### 注释

* 单行注释，用`//`起头；另一种是多行注释，放在`/*` 和 `*/`之间
* JavaScript兼容HTML代码的注释,`<!--`和`-->`也被视为单行注释（`-->`只有在行首，才会被当成单行注释，否则就是一个运算符）

### 区块

使用`大括号`，将多个相关的语句组合在一起，称为“*区块*”（block）

区块中的变量与区块外的变量，属于同一个作用域（ES6增加了[区块作用域](https://github.com/zhuwei05/blog/blob/master/js/es6%E5%AD%A6%E4%B9%A0\(1\).md#块级作用域)）

## 条件语句

### if 结构

	if (m === 3) {
	  m += 1;	
	}	

	if (m === 0) {
	  // ...
	} else if (m === 1) {
	  // ...
	} else if (m === 2) {
	  // ...
	} else {
	  // ...
	}

### switch结构

	switch (fruit) {
	  case "banana":
	    // ...
	    break;
	  case "apple":
	    // ...
	    break;
	  default:
	    // ...
	}
	
* `switch`语句部分和`case`语句部分，都可以使用`表达式`
* 每个`case`代码块内部的`break`语句不能少，否则会接下去执行下一个`case`代码块，而不是跳出`switch`结构
* `switch`语句后面的表达式与`case`语句后面的表示式，在比较运行结果时，采用的是严格相等运算符（`===`），而不是相等运算符（`==`），这意味着比较时不会发生类型转换
* `switch`结构不利于代码重用，往往可以用`对象形式`重写

## 循环语句

### while循环

	while (expression) {
	  statement
	}

### for循环
	
	for(initialize; test; increment) {
	  statement
	}	

* `for`语句后面的括号里面，有三个`表达式`
* `for`语句的三个部分（`initialize`，`test`，`increment`），可以省略任何一个，也可以全部省略

### do…while循环

`do...while`循环与`while`循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件

	do {
	  statement
	} while(expression);

### break语句和continue语句

`break`语句和`continue`语句都具有跳转作用，可以让代码不按既有的顺序执行

### 标签（label）

	label:
	  statement

* 标签可以是任意的标识符，但是不能是保留字，语句部分可以是任意语句
* 标签通常与`break`语句和`continue`语句配合使用，跳出特定的循环

## 数据类型

* 数值（number）：整数和小数（比如1和3.14）
* 字符串（string）：字符组成的文本（比如”Hello World”）
* 布尔值（boolean）：true（真）和false（假）两个特定值
* undefined：表示“未定义”或不存在，即此处目前没有任何值
* null：表示空缺，即此处应该有一个值，但目前为空
* 对象（object）：各种值组成的集合
* Symbol类型(ES6)

> 数值、字符串、布尔值称为`原始类型（primitive type）`的值，即它们是最基本的数据类型，不能再细分了。而将对象称为`合成类型（complex type）`的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于`undefined`s和`null`，一般将它们看成两个特殊值

对象又可以分成三个子类型:

* 狭义的对象（object）
* 数组（array）
* 函数（function）

### typeof运算符

JavaScript有三种方法，可以确定一个值到底是什么类型:

* `typeof`运算符
* `instanceof`运算符
* `Object.prototype.toString`方法

`typeof`运算符可以返回一个值的数据类型:

* 原始类型: 数值、字符串、布尔值分别返回`number`、`string`、`boolean`
	
		typeof 123 // "number"
* 函数: 返回`function`
* `undefined`: 返回`undefined`。利用这一点，typeof可以用来检查一个没有声明的变量，而不报错
* 其他：都返回`object`

		typeof window // "object"
		typeof {} // "object"
		typeof [] // "object"
		typeof null // "object"

	null的类型也是object，这是由于历史原因造成的
	
	`typeof`对数组（`array`）和对象（`object`）的显示结果都是`object`。`instanceof`运算符可以区分：
		
		var o = {};
		var a = [];
	
		o instanceof Array // false
		a instanceof Array // true

## null和undefined

`null`与`undefined`都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。

	var a = undefined;
	// 或者
	var a = null;

### 用法和含义

`null`表示空值，即该处的值现在为空。典型用法是：

* 作为函数的参数，表示该函数的参数是一个没有任何内容的对象
* 作为对象原型链的终点

`undefined`表示不存在值，就是此处目前不存在任何值。典型用法是：

* 变量被声明了，但没有赋值时，就等于undefined。
* 调用函数时，应该提供的参数没有提供，该参数等于undefined。
* 对象没有赋值的属性，该属性的值为undefined。
* 函数没有返回值时，默认返回undefined。

## 布尔值

“真”用关键字`true`表示，“假”用关键字`false`表示

返回布尔值的运算符

* 两元逻辑运算符： && (And)，|| (Or)
* 前置逻辑运算符： ! (Not)
* 相等运算符：===，!==，==，!=
* 比较运算符：>，>=，<，<=

如果发生自动转为布尔值，规则：以下转为`false`，其余为`true`

* undefined
* null
* false
* 0
* NaN
* ""（空字符串）

因此：特别注意的是，空数组（`[]`）和空对象（`{}`）对应的布尔值，都是`true`

# 数值

### 整数和浮点数

* 所有数字都是以64位浮点数形式储存，即使整数也是如此。
* 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心

### 数值精度

> 根据国际标准IEEE 754，64位浮点数格式的64个二进制位中，第0位到第51位储存有效数字部分（共52位），第52到第62位储存指数部分，第63位是符号位，0表示正数，1表示负数

> JavaScript提供的有效数字的精度为53个二进制位（IEEE 754规定有效数字第一位默认总是为1，不保存在64位浮点数之中，这一位再加上后面的52位，就是总共53位），也就是说，绝对值小于2的53次方的整数，即`-(2^53-1`)到`2^53-1`，都可以精确表示

#### 数值范围

> 另一方面，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则JavaScript能够表示的数值范围为2^1024到2^-1023（开区间），超出这个范围的数无法表示。

如果指数部分等于或超过最大正值1024，JavaScript会返回`Infinity`（关于Infinity的介绍参见下文），这称为`“正向溢出”`；如果等于或超过最小负值-1023（即非常接近0），JavaScript会直接把这个数转为0，这称为`“负向溢出”`。事实上，JavaScript对指数部分的两个极端值（`11111111111`和`00000000000`）做了定义，`11111111111`表示`NaN`和`Infinity`，`00000000000`表示`0`

具体的最大值和最小值，JavaScript提供Number对象的`MAX_VALUE`和`MIN_VALUE`属性表示

	Number.MAX_VALUE // 1.7976931348623157e+308
	Number.MIN_VALUE // 5e-324

## 数值的表示法

* 字面形式
* 采用科学计数法(`e`或`E`)
	
		123e3 // 123000
		123e-3 // 0.123
		-3.1E+12
		.1e-23

以下两种情况，JavaScript会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。

* 小数点前的数字多于21位

		1234567890123456789012
		// 1.2345678901234568e+21

		123456789012345678901
		// 123456789012345680000

* 小数点后的零多于5个

		0.0000003 // 3e-7
		0.000003 // 0.000003
		
## 数值的进制

* 十进制：没有前导0的数值。
* 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的七个阿拉伯数字的数值。
* 十六进制：有前缀0x或0X的数值。
* 二进制：有前缀0b或0B的数值。		

用前导0表示八进制，处理时很容易造成混乱。ES5的严格模式和ES6，已经废除了这种表示法，但是浏览器目前还支持。

## 特殊数值

### 正零和负零

严格来说，JavaScript提供零的三种写法：`0`、`+0`、`-0`。它们是等价的

	-0 === +0 // true
	0 === -0 // true
	0 === +0 // true
但是，如果正零和负零分别当作分母，它们返回的值是不相等的。

	(1/+0) === (1/-0) // false

上面代码之所以出现这样结果，是因为除以正零得到`+Infinity`，除以负零得到-`Infinity`，这两者是不相等的

### NaN

表示“非数字”（Not a Number）。

* 主要出现在将字符串解析成数字出错的场合
* 一些数学函数的运算结果会出现NaN
* 0除以0也会得到NaN
* NaN不是一种独立的数据类型，而是一种特殊数值，它的数据类型依然属于Number

运算规则：

* NaN不等于任何值，包括它本身：`NaN === NaN // false`
* NaN在布尔运算时被当作false
* NaN与任何数（包括它自己）的运算，得到的都是NaN

判断NaN的方法

* `isNaN`方法可以用来判断一个值是否为NaN。
* isNaN只对数值有效，如果传入其他值，会被先转成数值。也就是说，`isNaN`为`true`的值，有可能不是`NaN`，而是一个`字符串`
* 同样的，对于对象和数组，`isNaN`也返回`true`
* 对于空数组和只有一个数值成员的数组，isNaN返回false

**小结：**

因此，使用isNaN之前，最好判断一下数据类型：

	function myIsNaN(value) {
	  return typeof value === 'number' && isNaN(value);
	}

更可靠的方法是，利用NaN是JavaScript之中唯一不等于自身的值这个特点，进行判断：

	function myIsNaN(value) {
	  return value !== value;
	}

### Infinity

* Infinity表示“无穷”。除了0除以0得到NaN，其他任意数除以0，得到Infinity
* 需要特别注意的地方：非0值除以0，JavaScript不报错，而是返回Infinity
* Infinity有正负之分
* 运算结果超出JavaScript可接受范围，也会返回无穷
* 由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript都不报错，所以单纯的数学运算几乎没有可能抛出错误
* Infinity的四则运算，符合无穷的数学计算规则
* Infinity减去或除以Infinity，得到NaN
* Infinity可以用于布尔运算。可以记住，Infinity是JavaScript中最大的值（NaN除外），-Infinity是最小的值（NaN除外）
* isFinite函数返回一个布尔值，检查某个值是否为正常值，而不是Infinity
* `isFinite(NaN) // false`

## 与数值相关的全局方法

### parseInt()

* 将字符串转为整数。如果字符串头部有空格，空格会被自动去除
* parseInt的参数不是字符串，则会先转为字符串再转换
* 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分
* 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN
* parseInt的返回值只有两种可能，不是一个十进制整数，就是NaN
* 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析
* 如果字符串以0开头，ES5规定parseInt按照10进制解析
* 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果
* parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。parseInt的第二个参数默认为10，即默认情况下是十进制转十进制
* 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略
* 如果字符串包含对于指定进制无意义的字符，则返回NaN


### parseFloat()

* parseFloat方法用于将一个字符串转为浮点数
* 如果字符串符合科学计数法，则会进行相应的转换
* 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分
* parseFloat方法会自动过滤字符串前导的空格
* 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN

# 字符串

## 概述

* 字符串就是零个或多个排在一起的字符，放在单引号或双引号之中
* 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号

### 转义

### 字符串与数组

* 字符串可以被视为字符数组，因此可以使用数组的方括号运算符
* 如果方括号中的数字超过字符串的范围，或者方括号中根本不是数字，则返回`undefined`
* 无法改变字符串之中的单个字符
* 字符串也无法添加新属性，如果想要为字符串添加属性，只有在它的原型对象`String.prototype`上定义

### length属性

`length`属性返回字符串的长度，该属性也是无法改变的

## 字符集

JavaScript使用`Unicode`字符集，也就是说在JavaScript内部，所有字符都用Unicode表示。

不仅JavaScript内部使用Unicode储存字符，而且还可以直接在程序中使用Unicode，所有字符都可以写成`\uxxxx`的形式，其中xxxx代表该字符的Unicode编码。比如，`\u00A9`代表版权符号。

**注意：**
> JavaScript引擎（严格说是ES5规格）不能自动识别辅助平面（编号大于0xFFFF）的Unicode字符。ES6不存在该问题了。

## Base64转码

Base64是一种编码方法，可以将任意字符转成可打印字符。使用这种编码方法，主要不是为了加密，而是*为了不出现特殊字符，简化程序的处理*。

JavaScript原生提供两个Base64相关方法。

* btoa()：字符串或二进制值转为Base64编码
* atob()：Base64编码转为原来的编码

**注意：**
> 这两个方法不适合非ASCII码的字符，会报错，要将非ASCII码字符转为Base64编码，必须中间插入一个转码环节，再使用这两个方法













## 参考

* [JavaScript 标准参考教程](http://javascript.ruanyifeng.com/)