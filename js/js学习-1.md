title: js学习(1)
date: 2016-04-05 12:05:05
tags:
- js

# js学习(1)
---
没有系统学习过js，觉得基础太薄弱了，参考阮一峰老师的[JavaScript 标准参考教程](http://javascript.ruanyifeng.com/)，希望可以提高自己js的基础。

# 2. 基本语法
------

# 基本句法和变量

### 语句

**语句（statement）**是为了完成某种任务而进行的操作

	var a = 1 + 3;

**表达式（expression）**为了得到返回值的计算式。

	1 + 3

> 语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。

* 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。
* 表达式不需要分号结尾。一旦在表达式后面添加分号，则JavaScript引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。

### 变量

	var a;
	a = 1;
	var a = 1;

* 变量是对“值”的引用，使用变量等同于引用一个值。
* 变量的声明和赋值，是分开的两个步骤。但是可以合起来一起写。
* 只是声明变量而没有赋值，则该变量的值是不存在的，JavaScript使用`undefined`表示这种情况。
* 没有声明就直接使用，JavaScript会报错，告诉你变量未定义

#### 变量提升

JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做**变量提升（hoisting）**

	console.log(a); // undefined
	var a = 1;
	
	==>
	
	var a;
	console.log(a);  // undefined
	a = 1;

变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。

### 标识符

* 第一个字符，可以是任意Unicode字母，以及美元符号（$）和下划线（_）。
* 第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字0-9。
* JavaScript有一些保留字，不能用作标识符
* 不应该用作标识符：`Infinity`、`NaN`、`undefined`

### 注释

* 单行注释，用`//`起头；另一种是多行注释，放在`/*` 和 `*/`之间
* JavaScript兼容HTML代码的注释,`<!--`和`-->`也被视为单行注释（`-->`只有在行首，才会被当成单行注释，否则就是一个运算符）

### 区块

使用`大括号`，将多个相关的语句组合在一起，称为“*区块*”（block）

区块中的变量与区块外的变量，属于同一个作用域（ES6增加了[区块作用域](https://github.com/zhuwei05/blog/blob/master/js/es6%E5%AD%A6%E4%B9%A0\(1\).md#块级作用域)）

## 条件语句

### if 结构

	if (m === 3) {
	  m += 1;	
	}	

	if (m === 0) {
	  // ...
	} else if (m === 1) {
	  // ...
	} else if (m === 2) {
	  // ...
	} else {
	  // ...
	}

### switch结构

	switch (fruit) {
	  case "banana":
	    // ...
	    break;
	  case "apple":
	    // ...
	    break;
	  default:
	    // ...
	}
	
* `switch`语句部分和`case`语句部分，都可以使用`表达式`
* 每个`case`代码块内部的`break`语句不能少，否则会接下去执行下一个`case`代码块，而不是跳出`switch`结构
* `switch`语句后面的表达式与`case`语句后面的表示式，在比较运行结果时，采用的是严格相等运算符（`===`），而不是相等运算符（`==`），这意味着比较时不会发生类型转换
* `switch`结构不利于代码重用，往往可以用`对象形式`重写

## 循环语句

### while循环

	while (expression) {
	  statement
	}

### for循环
	
	for(initialize; test; increment) {
	  statement
	}	

* `for`语句后面的括号里面，有三个`表达式`
* `for`语句的三个部分（`initialize`，`test`，`increment`），可以省略任何一个，也可以全部省略

### do…while循环

`do...while`循环与`while`循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件

	do {
	  statement
	} while(expression);

### break语句和continue语句

`break`语句和`continue`语句都具有跳转作用，可以让代码不按既有的顺序执行

### 标签（label）

	label:
	  statement

* 标签可以是任意的标识符，但是不能是保留字，语句部分可以是任意语句
* 标签通常与`break`语句和`continue`语句配合使用，跳出特定的循环

## 数据类型

* 数值（number）：整数和小数（比如1和3.14）
* 字符串（string）：字符组成的文本（比如”Hello World”）
* 布尔值（boolean）：true（真）和false（假）两个特定值
* undefined：表示“未定义”或不存在，即此处目前没有任何值
* null：表示空缺，即此处应该有一个值，但目前为空
* 对象（object）：各种值组成的集合
* Symbol类型(ES6)

> 数值、字符串、布尔值称为`原始类型（primitive type）`的值，即它们是最基本的数据类型，不能再细分了。而将对象称为`合成类型（complex type）`的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于`undefined`s和`null`，一般将它们看成两个特殊值

对象又可以分成三个子类型:

* 狭义的对象（object）
* 数组（array）
* 函数（function）

### typeof运算符

JavaScript有三种方法，可以确定一个值到底是什么类型:

* `typeof`运算符
* `instanceof`运算符
* `Object.prototype.toString`方法

`typeof`运算符可以返回一个值的数据类型:

* 原始类型: 数值、字符串、布尔值分别返回`number`、`string`、`boolean`
	
		typeof 123 // "number"
* 函数: 返回`function`
* `undefined`: 返回`undefined`。利用这一点，typeof可以用来检查一个没有声明的变量，而不报错
* 其他：都返回`object`

		typeof window // "object"
		typeof {} // "object"
		typeof [] // "object"
		typeof null // "object"

	null的类型也是object，这是由于历史原因造成的
	
	`typeof`对数组（`array`）和对象（`object`）的显示结果都是`object`。`instanceof`运算符可以区分：
		
		var o = {};
		var a = [];
	
		o instanceof Array // false
		a instanceof Array // true

## null和undefined

`null`与`undefined`都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。

	var a = undefined;
	// 或者
	var a = null;

### 用法和含义

`null`表示空值，即该处的值现在为空。典型用法是：

* 作为函数的参数，表示该函数的参数是一个没有任何内容的对象
* 作为对象原型链的终点

`undefined`表示不存在值，就是此处目前不存在任何值。典型用法是：

* 变量被声明了，但没有赋值时，就等于undefined。
* 调用函数时，应该提供的参数没有提供，该参数等于undefined。
* 对象没有赋值的属性，该属性的值为undefined。
* 函数没有返回值时，默认返回undefined。

## 布尔值

“真”用关键字`true`表示，“假”用关键字`false`表示

返回布尔值的运算符

* 两元逻辑运算符： && (And)，|| (Or)
* 前置逻辑运算符： ! (Not)
* 相等运算符：===，!==，==，!=
* 比较运算符：>，>=，<，<=

如果发生自动转为布尔值，规则：以下转为`false`，其余为`true`

* undefined
* null
* false
* 0
* NaN
* ""（空字符串）

因此：特别注意的是，空数组（`[]`）和空对象（`{}`）对应的布尔值，都是`true`

# 数值

### 整数和浮点数

* 所有数字都是以64位浮点数形式储存，即使整数也是如此。
* 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心

### 数值精度

> 根据国际标准IEEE 754，64位浮点数格式的64个二进制位中，第0位到第51位储存有效数字部分（共52位），第52到第62位储存指数部分，第63位是符号位，0表示正数，1表示负数

> JavaScript提供的有效数字的精度为53个二进制位（IEEE 754规定有效数字第一位默认总是为1，不保存在64位浮点数之中，这一位再加上后面的52位，就是总共53位），也就是说，绝对值小于2的53次方的整数，即`-(2^53-1`)到`2^53-1`，都可以精确表示

#### 数值范围

> 另一方面，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则JavaScript能够表示的数值范围为2^1024到2^-1023（开区间），超出这个范围的数无法表示。

如果指数部分等于或超过最大正值1024，JavaScript会返回`Infinity`（关于Infinity的介绍参见下文），这称为`“正向溢出”`；如果等于或超过最小负值-1023（即非常接近0），JavaScript会直接把这个数转为0，这称为`“负向溢出”`。事实上，JavaScript对指数部分的两个极端值（`11111111111`和`00000000000`）做了定义，`11111111111`表示`NaN`和`Infinity`，`00000000000`表示`0`

具体的最大值和最小值，JavaScript提供Number对象的`MAX_VALUE`和`MIN_VALUE`属性表示

	Number.MAX_VALUE // 1.7976931348623157e+308
	Number.MIN_VALUE // 5e-324

## 数值的表示法

* 字面形式
* 采用科学计数法(`e`或`E`)
	
		123e3 // 123000
		123e-3 // 0.123
		-3.1E+12
		.1e-23

以下两种情况，JavaScript会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。

* 小数点前的数字多于21位

		1234567890123456789012
		// 1.2345678901234568e+21

		123456789012345678901
		// 123456789012345680000

* 小数点后的零多于5个

		0.0000003 // 3e-7
		0.000003 // 0.000003
		
## 数值的进制

* 十进制：没有前导0的数值。
* 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的七个阿拉伯数字的数值。
* 十六进制：有前缀0x或0X的数值。
* 二进制：有前缀0b或0B的数值。		

用前导0表示八进制，处理时很容易造成混乱。ES5的严格模式和ES6，已经废除了这种表示法，但是浏览器目前还支持。

## 特殊数值

### 正零和负零

严格来说，JavaScript提供零的三种写法：`0`、`+0`、`-0`。它们是等价的

	-0 === +0 // true
	0 === -0 // true
	0 === +0 // true
但是，如果正零和负零分别当作分母，它们返回的值是不相等的。

	(1/+0) === (1/-0) // false

上面代码之所以出现这样结果，是因为除以正零得到`+Infinity`，除以负零得到-`Infinity`，这两者是不相等的

### NaN

表示“非数字”（Not a Number）。

* 主要出现在将字符串解析成数字出错的场合
* 一些数学函数的运算结果会出现NaN
* 0除以0也会得到NaN
* NaN不是一种独立的数据类型，而是一种特殊数值，它的数据类型依然属于Number

运算规则：

* NaN不等于任何值，包括它本身：`NaN === NaN // false`
* NaN在布尔运算时被当作false
* NaN与任何数（包括它自己）的运算，得到的都是NaN

判断NaN的方法

* `isNaN`方法可以用来判断一个值是否为NaN。
* isNaN只对数值有效，如果传入其他值，会被先转成数值。也就是说，`isNaN`为`true`的值，有可能不是`NaN`，而是一个`字符串`
* 同样的，对于对象和数组，`isNaN`也返回`true`
* 对于空数组和只有一个数值成员的数组，isNaN返回false

**小结：**

因此，使用isNaN之前，最好判断一下数据类型：

	function myIsNaN(value) {
	  return typeof value === 'number' && isNaN(value);
	}

更可靠的方法是，利用NaN是JavaScript之中唯一不等于自身的值这个特点，进行判断：

	function myIsNaN(value) {
	  return value !== value;
	}

### Infinity

* Infinity表示“无穷”。除了0除以0得到NaN，其他任意数除以0，得到Infinity
* 需要特别注意的地方：非0值除以0，JavaScript不报错，而是返回Infinity
* Infinity有正负之分
* 运算结果超出JavaScript可接受范围，也会返回无穷
* 由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript都不报错，所以单纯的数学运算几乎没有可能抛出错误
* Infinity的四则运算，符合无穷的数学计算规则
* Infinity减去或除以Infinity，得到NaN
* Infinity可以用于布尔运算。可以记住，Infinity是JavaScript中最大的值（NaN除外），-Infinity是最小的值（NaN除外）
* isFinite函数返回一个布尔值，检查某个值是否为正常值，而不是Infinity
* `isFinite(NaN) // false`

## 与数值相关的全局方法

### parseInt()

* 将字符串转为整数。如果字符串头部有空格，空格会被自动去除
* parseInt的参数不是字符串，则会先转为字符串再转换
* 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分
* 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN
* parseInt的返回值只有两种可能，不是一个十进制整数，就是NaN
* 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析
* 如果字符串以0开头，ES5规定parseInt按照10进制解析
* 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果
* parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。parseInt的第二个参数默认为10，即默认情况下是十进制转十进制
* 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略
* 如果字符串包含对于指定进制无意义的字符，则返回NaN


### parseFloat()

* parseFloat方法用于将一个字符串转为浮点数
* 如果字符串符合科学计数法，则会进行相应的转换
* 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分
* parseFloat方法会自动过滤字符串前导的空格
* 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN

# 字符串

## 概述

* 字符串就是零个或多个排在一起的字符，放在单引号或双引号之中
* 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号

### 转义

### 字符串与数组

* 字符串可以被视为字符数组，因此可以使用数组的方括号运算符
* 如果方括号中的数字超过字符串的范围，或者方括号中根本不是数字，则返回`undefined`
* 无法改变字符串之中的单个字符
* 字符串也无法添加新属性，如果想要为字符串添加属性，只有在它的原型对象`String.prototype`上定义

### length属性

`length`属性返回字符串的长度，该属性也是无法改变的

## 字符集

JavaScript使用`Unicode`字符集，也就是说在JavaScript内部，所有字符都用Unicode表示。

不仅JavaScript内部使用Unicode储存字符，而且还可以直接在程序中使用Unicode，所有字符都可以写成`\uxxxx`的形式，其中xxxx代表该字符的Unicode编码。比如，`\u00A9`代表版权符号。

**注意：**
> JavaScript引擎（严格说是ES5规格）不能自动识别辅助平面（编号大于0xFFFF）的Unicode字符。ES6不存在该问题了。

## Base64转码

Base64是一种编码方法，可以将任意字符转成可打印字符。使用这种编码方法，主要不是为了加密，而是*为了不出现特殊字符，简化程序的处理*。

JavaScript原生提供两个Base64相关方法。

* btoa()：字符串或二进制值转为Base64编码
* atob()：Base64编码转为原来的编码

**注意：**
> 这两个方法不适合非ASCII码的字符，会报错，要将非ASCII码字符转为Base64编码，必须中间插入一个转码环节，再使用这两个方法

# 对象

## 概述

* 所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成
* 对象的所有键名都是字符串，所以加不加引号都可以（注意json中字符串必须加引号）
* 但是，如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号
* JavaScript的保留字可以不加引号当作键名
* 键名是数字，则会默认转为对应的字符串

### 属性

* 对象的每一个“键名”又称为“属性”（property），它的“键值”可以是任何数据类型。
* 如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用
* 对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。（ES6建议都添加）
* 由于对象的方法就是函数，因此也有`name`属性

### 生成方法

* 使用大括号生成（`{}`）
* 用`new`命令生成一个Object对象的实例，
* 使用`Object.create`方法生成

```javascript

	var o1 = {};
	var o2 = new Object();
	var o3 = Object.create(null);
	
```

### 读写属性

**读取属性：**`[]`和`.`

* 使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。但是，数字键可以不加引号，因为会被当作字符串处理。
* 方括号运算符内部可以使用表达式
* 数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符
* 检查变量是否声明：如果读取一个不存在的键，会返回undefined，而不是报错。可以利用这一点，来检查一个变量是否被声明

		if('a' in window) {
  			...
		}
		
**写入属性：**`[]`和`.`

JavaScript允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。

	var o = { p: 1 };
	
	// 等价于
	
	var o = {};
	o.p = 1;

ES6不建议这么使用，要么一开始定义好属性，要么使用`Object.assign`

**查看所有属性**： 查看一个对象本身的所有属性，可以使用`Object.keys`方法	

### 属性的删除

删除一个属性，需要使用`delete`命令

* 如果删除一个不存在的属性，delete不报错，而且返回true。

	换句话说：delete命令只能用来保证某个属性的值为undefined，而无法保证该属性是否真的存在
	
* 该属性存在，且不得删除，delete命令会返回false
* delete命令只能删除对象本身的属性，不能删除继承的属性
* delete命令也不能删除var命令声明的变量，只能用来删除属性

### 对象的引用

如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。

	var o1 = {};
	var o2 = o1;
	
	o1.a = 1;
	o2.a // 1
	
	o2.b = 2;
	o1.b // 2
	
这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝

### in运算符

* in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回`true`，否则返回`false`	
	在JavaScript语言中，所有全局变量都是顶层对象（浏览器的顶层对象就是window对象）的属性，因此*可以用in运算符判断，一个全局变量是否存在*
	
* in运算符的一个问题是，它不能识别对象继承的属性，对继承的属性也返回`true`


### for…in循环

* `for...in`循环用来遍历一个对象的全部属性
* `for...in`循环遍历的是对象所有可`enumberable`的属性，其中不仅包括定义在对象本身的属性，还包括对象继承的属性

		// name 是 Person 本身的属性
		function Person(name) {
		  this.name = name;
		}
		
		// describe是Person.prototype的属性
		Person.prototype.describe = function () {
		  return 'Name: '+this.name;
		};
		
		var person = new Person('Jane');
		
		// for...in循环会遍历实例自身的属性（name），
		// 以及继承的属性（describe）
		for (var key in person) {
		  console.log(key);
		}
		// name
		// describe	
		
* 如果只想遍历对象本身的属性，可以使用hasOwnProperty方法，在循环内部做一个判断

		for (var key in person) {
		  if (person.hasOwnProperty(key)) {
		    console.log(key);
		  }
		}
		// name
		
### with语句

`with`语句：

	with (object) {
	  statements;
	}

它的作用是操作同一个对象的多个属性时，提供一些书写的方便。

* `with`区块内部的变量，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。这是因为with区块没有改变作用域，它的内部依然是当前作用域。`with`语句的一个很大的弊病，就是绑定对象不明确。
* with语句少数有用场合之一，就是替换模板变量。

	
# 数组

## 定义

> 》数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。

* 除了在定义时赋值，数组也可以先定义后赋值
* 任何类型的数据，都可以放入数组
* 如果数组的元素还是数组，就形成了多维数组

## 数组的本质

本质上，数组属于一种特殊的对象。`typeof`运算符会返回数组的类型是`object`。

	typeof [1, 2, 3] // "object"

* 数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。

	对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。
	
## length属性

* 数组的length属性，返回数组的成员数量
* JavaScript使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有`4294967295`个（2^32-1）个，也就是说length属性的最大值就是4294967295
* 数组的`length`属性与对象的`length`属性有区别，只要是数组，就一定有`length`属性，而对象不一定有。而且，数组的`length`属性是一个动态的值，等于键名中的最大整数加上1
* 将数组清空的一个有效方法，就是将length属性设为0。
* 如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位
* 值得注意的是，由于数组本质上是对象的一种，所以我们可以为数组添加属性，但是这不影响length属性的值

## 类似数组的对象

> 它们看上去很像数组，可以使用length属性，但是它们并不是数组，所以无法使用一些数组的方法

下面就是一个类似数组的对象。

	var obj = {
	  0: 'a',
	  1: 'b',
	  2: 'c',
	  length: 3
	};
	
	obj[0] // 'a'
	obj[2] // 'c'
	obj.length // 3
	
* 典型的类似数组的对象是函数的`arguments`对象，以及大多数`DOM`元素集，还有`字符串`
* 数组的slice方法将类似数组的对象，变成真正的数组

		var arr = Array.prototype.slice.call(arrayLike);
		
* 遍历类似数组的对象，可以采用`for`循环，也可以采用数组的`forEach`方法

		// for循环
		function logArgs() {
		  for (var i = 0; i < arguments.length; i++) {
		    console.log(i + '. ' + arguments[i]);
		  }
		}
		
		// forEach方法
		function logArgs() {
		    Array.prototype.forEach.call(arguments, function (elem, i) {
		        console.log(i+'. '+elem);
		    });
		}		

## in运算符

检查某个键名是否存在的运算符`in`，适用于对象，也适用于数组

## for…in

* 使用`for...in`循环，可以遍历数组的所有元素。需要注意的是，`for...in`会遍历数组所有的键，即使是非数字键
* 其他的数组遍历方法，就是使用`length`属性，结合`for`循环或者`while`循环	
* 数组的forEach方法，也可以用来遍历数组

## 数组的空位

> 当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位

* 数组的空位不影响length属性
* 如果最后一个元素后面有逗号，并不会产生空位
* 数组的空位是可以读取的，返回`undefined`
* 使用`delete`命令删除一个值，会形成空位
* `delete`命令不影响length属性
* 数组的某个位置是空位，与某个位置是`undefined`，是不一样的。如果是空位，使用数组的`forEach`方法、`for...in`结构、以及`Object.keys`方法进行遍历，空位都会被跳过

# 函数

## 概述

> 函数就是一段预先设置的代码块，可以反复调用，根据输入参数的不同，返回不同的值。

### 函数的声明

* function命令

		function print(s) {
		  console.log(s);
		}


* 函数表达式

	可以采用变量赋值的写法:

		var print = function(s) {
		  console.log(s);
		};	
	
	采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效
	
	需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号
	
	这两种声明函数的方式，差别很细微（参阅后文《变量提升》一节）
	
* Function构造函数

		var add = new Function(
		  'x',
		  'y',
		  'return (x + y)'
		);
		
		// 等同于
		
		function add(x, y) {
		  return (x + y);
		}	

	Function构造函数可以不使用new命令，返回结果完全一样。

	总的来说，这种声明函数的方式非常不直观，几乎无人使用


说明：

* 如果同一个函数被多次声明，后面的声明就会覆盖前面的声明
* 调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数 

### 第一等公民

JavaScript的函数与其他数据类型（数值、字符串、布尔值等等）处于同等地位，可以使用其他数据类型的地方，就能使用函数。

这表明，函数与其他数据类型完全是平等的，所以又称函数为第一等公民

### 函数名的提升

JavaScript引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。

### 不能在条件语句中声明函数

根据ECMAScript的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句


## 函数的属性和方法

* name属性

	name属性返回紧跟在function关键字之后的那个函数名

* length属性

	length属性返回函数预期传入的参数个数，即函数定义之中的参数个数
	
* toString()

	函数的toString方法返回函数的源码
	
## 函数作用域

作用域（scope）指的是变量存在的范围。Javascript只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。

**注意： ES6中新增块作用域**		


* 函数内部的变量提升

	与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部

* 函数本身的作用域

	函数本身也是一个值，也有自己的作用域。它的作用域绑定其声明时所在的作用域

## 参数

* 参数的省略

	函数参数不是必需的，Javascript允许省略参数

	被省略的参数的值就变为`undefined`。需要注意的是，函数的`length`属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。

	但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入`undefined`
	
* 默认值

	通过下面的方法，可以为函数的参数设置默认值	

















## 参考

* [JavaScript 标准参考教程](http://javascript.ruanyifeng.com/)