title: ES6学习(3)
date: 2016-04-03 18:20:05
tags:
- es6
- js

# ES6学习(3)

## Generator 函数

### 基本概念

Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。

Generator函数有多种理解角度。`从语法上`，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。

执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。

`形式上`，Generator函数是一个普通函数，但是有两个特征。

* function关键字与函数名之间有一个星号；
* 函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。

例如：

	function* helloWorldGenerator() {
	  yield 'hello';
	  yield 'world';
	  return 'ending';
	}

	var hw = helloWorldGenerator();
	
	hw.next()
	// { value: 'hello', done: false }
	
	hw.next()
	// { value: 'world', done: false }
	
	hw.next()
	// { value: 'ending', done: true }
	
	hw.next()
	// { value: undefined, done: true }

上面代码定义了一个Generator函数helloWorldGenerator，它内部有两个yield语句“hello”和“world”，即该函数有三个状态：hello，world和return语句（结束执行）。

然后，Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。

下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。

ES6没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。

	function * foo(x, y) { ··· }
	
	function *foo(x, y) { ··· }
	
	function* foo(x, y) { ··· }
	
	function*foo(x, y) { ··· }
	
由于Generator函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面

### yield语句

由于`Generator`函数返回的遍历器对象，只有调用`next`方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。`yield`语句就是暂停标志

### next方法的参数

yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。

这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态（`context`）是不变的。通过`next`方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部`注入值`。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。

**注意**，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。

如果想要第一次调用next方法时，就能够输入值，可以在Generator函数外面再包一层。

### for...of循环

`for...of`循环可以自动遍历Generator函数，且此时不再需要调用`next`方法

`for...of`循环、扩展运算符（`...`）、解构赋值和`Array.from`方法内部调用的，都是遍历器接口。这意味着，它们可以将Generator函数返回的Iterator对象，作为参数。

利用`for...of`循环，可以写出遍历任意对象的方法。原生的JavaScript对象没有遍历接口，无法使用for...of循环，通过`Generator`函数为它加上这个接口，就可以用了。

	function* objectEntries(obj) {
	  let propKeys = Reflect.ownKeys(obj);
	
	  for (let propKey of propKeys) {
	    yield [propKey, obj[propKey]];
	  }
	}
	
	let jane = { first: 'Jane', last: 'Doe' };
	
	for (let [key, value] of objectEntries(jane)) {
	  console.log(`${key}: ${value}`);
	}
	// first: Jane
	// last: Doe


### Generator.prototype.throw()

Generator函数返回的遍历器对象，都有一个`throw`方法，可以在函数体外抛出错误，然后在Generator函数体内捕获

**注意**：不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。

### Generator.prototype.return()

Generator函数返回的遍历器对象，还有一个`return`方法，可以返回给定的值，并且终结遍历Generator函数。

如果`return`方法调用时，不提供参数，则返回值的`vaule`属性为`undefined`

如果Generator函数内部有`try...finally`代码块，那么`return`方法会推迟到`finally`代码块执行完再执行

### yield*语句

如果在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果的。这个就需要用到`yield*`语句，用来在一个Generator函数里面执行另一个Generator函数。

从语法角度看，如果`yield`命令后面跟的是一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。这被称为`yield*`语句。

`yield*`语句等同于在Generator函数内部，部署一个`for...of`循环。`yield*`不过是`for...of`的一种简写形式，完全可以用后者替代前者

如果`yield*`后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员

任何数据结构只要有`Iterator`接口，就可以被`yield*`遍历


	let delegatedIterator = (function* () {
	  yield 'Hello!';
	  yield 'Bye!';
	}());
	
	let delegatingIterator = (function* () {
	  yield 'Greetings!';
	  yield* delegatedIterator;
	  yield 'Ok, bye.';
	}());
	
	for(let value of delegatingIterator) {
	  console.log(value);
	}
	// "Greetings!
	// "Hello!"
	// "Bye!"
	// "Ok, bye."

上面代码中，`delegatingIterator`是代理者，`delegatedIterator`是被代理者。由于`yield* delegatedIterator`语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果

如果被代理的Generator函数有`return`语句，那么就可以向代理它的Generator函数返回数据

`yield*`命令可以很方便地取出嵌套数组的所有成员

	function* iterTree(tree) {
	  if (Array.isArray(tree)) {
	    for(let i=0; i < tree.length; i++) {
	      yield* iterTree(tree[i]);
	    }
	  } else {
	    yield tree;
	  }
	}
	
	const tree = [ 'a', ['b', 'c'], ['d', 'e'] ];
	
	for(let x of iterTree(tree)) {
	  console.log(x);
	}
	// a
	// b
	// c
	// d
	// e

下面是一个稍微复杂的例子，使用yield*语句遍历完全二叉树。

	// 下面是二叉树的构造函数，
	// 三个参数分别是左树、当前节点和右树
	function Tree(left, label, right) {
	  this.left = left;
	  this.label = label;
	  this.right = right;
	}
	
	// 下面是中序（inorder）遍历函数。
	// 由于返回的是一个遍历器，所以要用generator函数。
	// 函数体内采用递归算法，所以左树和右树要用yield*遍历
	function* inorder(t) {
	  if (t) {
	    yield* inorder(t.left);
	    yield t.label;
	    yield* inorder(t.right);
	  }
	}
	
	// 下面生成二叉树
	function make(array) {
	  // 判断是否为叶节点
	  if (array.length == 1) return new Tree(null, array[0], null);
	  return new Tree(make(array[0]), array[1], make(array[2]));
	}
	let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);
	
	// 遍历二叉树
	var result = [];
	for (let node of inorder(tree)) {
	  result.push(node);
	}
	
	result
	// ['a', 'b', 'c', 'd', 'e', 'f', 'g']
	
### 作为对象属性的Generator函数

如果一个对象的属性是Generator函数，可以简写成下面的形式。

	let obj = {
	 * myGeneratorMethod() {
	   ···
	 }
	};

上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个Generator函数。

它的完整形式如下，与上面的写法是等价的。
	
	let obj = {
	  myGeneratorMethod: function* () {
	    // ···
	  }
	};	

### Generator函数的this 

Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的`prototype`对象上的方法

如果要把Generator函数当作正常的构造函数使用，可以采用下面的变通方法。首先，生成一个空对象，使用bind方法绑定Generator函数内部的this。这样，构造函数调用以后，这个空对象就是Generator函数的实例对象了。

	function* F(){
	  yield this.x = 2;
	  yield this.y = 3;
	}
	var obj = {};
	var f = F.bind(obj)();
	
	f.next();  // Object {value: 2, done: false}
	f.next();  // Object {value: 3, done: false}
	f.next();  // Object {value: undefined, done: true}
	
	obj // { x: 2, y: 3 }
	
	
### Generator函数推导

ES7在数组推导的基础上，提出了Generator函数推导（Generator comprehension）。

	let generator = function* () {
	  for (let i = 0; i < 6; i++) {
	    yield i;
	  }
	}
	
	let squared = ( for (n of generator()) n * n );
	// 等同于
	// let squared = Array.from(generator()).map(n => n * n);
	
	console.log(...squared);
	// 0 1 4 9 16 25	
	
Generator函数推导是对数组结构的一种模拟，它的最大优点是`惰性求值`，即直到真正用到时才会求值，这样可以保证效率。	
	// 不使用Generator函数推导
	let bigArray = new Array(100000);
	for (let i = 0; i < 100000; i++) {
	  bigArray[i] = i;
	}
	
	let first = bigArray.map(n => n * n)[0];
	console.log(first);
	
	// 使用Generator推导	
	let bigGenerator = function* () {
	  for (let i = 0; i < 100000; i++) {
	    yield i;
	  }
	}
	
	let squared = ( for (n of bigGenerator()) n * n );
	
	console.log(squared.next());	
	
### 含义

#### Generator与状态机

Generator是实现状态机的最佳结构	
	
#### Generator与协程

Generator函数是ECMAScript 6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”（semi-coroutine），意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。

如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。（`Koa的实现`）


### 应用

Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。

#### 异步操作的同步化表达

Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。
	
Ajax是典型的异步操作，通过Generator函数部署Ajax操作，可以用同步的方式表达：
	
	function* main() {
	  var result = yield request("http://some.url");
	  var resp = JSON.parse(result);
	    console.log(resp.value);
	}
	
	function request(url) {
	  makeAjaxCall(url, function(response){
	    it.next(response);
	  });
	}
	
	var it = main();
	it.next();	

#### 控制流管理 

如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。

	step1(function (value1) {
	  step2(value1, function(value2) {
	    step3(value2, function(value3) {
	      step4(value3, function(value4) {
	        // Do something with value4
	      });
	    });
	  });
	});
采用Promise改写上面的代码。

	Q.fcall(step1)
	  .then(step2)
	  .then(step3)
	  .then(step4)
	  .then(function (value4) {
	    // Do something with value4
	  }, function (error) {
	    // Handle any error from step1 through step4
	  })
	  .done();
上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量Promise的语法。Generator函数可以进一步改善代码运行流程。

	function* longRunningTask() {
	  try {
	    var value1 = yield step1();
	    var value2 = yield step2(value1);
	    var value3 = yield step3(value2);
	    var value4 = yield step4(value3);
	    // Do something with value4
	  } catch (e) {
	    // Handle any error from step1 through step4
	  }
	}
然后，使用一个函数，按次序自动执行所有步骤。

	scheduler(longRunningTask());
	
	function scheduler(task) {
	  setTimeout(function() {
	    var taskObj = task.next(task.value);
	    // 如果Generator函数未结束，就继续调用
	    if (!taskObj.done) {
	      task.value = taskObj.value
	      scheduler(task);
	    }
	  }, 0);
	}
注意，yield语句是同步运行，不是异步运行（否则就失去了取代回调函数的设计目的了）。实际操作中，一般让yield语句返回Promise对象。

	var Q = require('q');
	
	function delay(milliseconds) {
	  var deferred = Q.defer();
	  setTimeout(deferred.resolve, milliseconds);
	  return deferred.promise;
	}
	
	function* f(){
	  yield delay(100);
	};
上面代码使用Promise的函数库Q，yield语句返回的就是一个Promise对象。

多个任务按顺序一个接一个执行时，yield语句可以按顺序排列。多个任务需要并列执行时（比如只有A任务和B任务都执行完，才能执行C任务），可以采用数组的写法。

	function* parallelDownloads() {
	  let [text1,text2] = yield [
	    taskA(),
	    taskB()
	  ];
	  console.log(text1, text2);
	}
上面代码中，yield语句的参数是一个数组，成员就是两个任务taskA和taskB，只有等这两个任务都完成了，才会接着执行下面的语句。

#### 作为数据结构

Generator可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。


	

## 参考

* [ECMAScript 6入门](http://es6.ruanyifeng.com/)