#Python进阶

##isinstance


##getattr

##@staticmethod @property


##可变和不可变

> 元组，string，数字做函数参数，在内部改变不了。列表可改变。

	def try_to_change(n):
		n = 'Mr. Right'
	
	name = 'Miss. Right'
	try_to_change(name)
	解析：
	n = name
	n = 'Mr. Right'
	
	def chagne(n):
		n[0] = 'Mr. Right'
	
	names = ['Miss. A', 'Miss. B']
	changes(names)
	解析：
	n = names
	n[0] = 'Mr. Right'
	
	进一步，如果用切片，因为切片生成的是副本，所以也不会改变
	change(names[:])


##深入 Python 函数定义

###默认参数值

为一个或多个参数指定默认值。这会创建一个可以使用比定义时允许的参数更少的参数调用的函数

**重要警告: 默认值只被赋值一次。这使得当默认值是可变对象时会有所不同，比如列表、字典或者大多数类的实例。**

###关键字参数

函数可以通过 关键字参数 的形式来调用，形如 `keyword = value`。

在函数调用中，关键字的参数必须跟随在位置参数的后面。传递的所有关键字参数必须与函数接受的某个参数相匹配，它们的顺序并不重要。这也包括非可选参数。

引入一个形如 `**name` 的参数时，它接收一个字典，该字典包含了所有未出现在形式参数列表中的关键字参数。这里可能还会组合使用一个形如 `*name` 的形式参数，它接收一个元组(下一节中会详细介绍)，包含了所有没有出现在形式参数列表中的参数值。( **\*name 必须在 \*\*name 之前出现**)


###可变参数列表

最后，一个最不常用的选择是可以让函数调用可变个数的参数。这些参数被包装进一个元组.

###参数列表的分拆

当你要传递的参数已经是一个列表，但要调用的函数却接受分开一个个的参数值。这时候你要把已有的列表拆开来。

例如内建函数 range() 需要独立的 start ，stop 参数。 你可以在调用函数时加一个 `*` 操作符来自动把参数列表拆开:

	>>> list(range(3, 6))            # normal call with separate arguments
	[3, 4, 5]
	>>> args = [3, 6]
	>>> list(range(*args))            # call with arguments unpacked from a list
	[3, 4, 5]

以同样的方式，可以使用 `**` 操作符分拆关键字参数为字典。

###Lambda 形式


##模块

模块是包括 Python 定义和声明的文件。文件名就是模块名加上 .py 后缀。模块的模块名(做为一个字符串)可以由全局变量 `__name__` 得到。

> 出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果你修改了你的模块，需要重启解释器或者如果你就是想交互式的测试这么一个模块，可以用 reload() 重新加载，例如 reload(modulename)。

作为脚本来执行模块时，`__name__` 被设置为 `"__main__"`。这相当于，如果你在模块后加入如下代码:

	if __name__ == "__main__":
		...

### dir() 函数
内置函数 dir() 用于按模块名搜索模块定义，它返回一个排好序的字符串类型的存储列表:

	>>> dir(sys)  

dir() 不会列出内置函数和变量名。如果你想列出这些内容，它们在标准模块 `__builtin__` 中定义:

	>>> import __builtin__
	>>> dir(__builtin__)  

##包

包通常是使用用“圆点模块名”的结构化模块命名空间。例如，名为 A.B 的模块表示了名为 A 的包中名为 B 的子模块。

为了让 Python 将目录当做内容包，目录中必须包含 `__init__.py` 文件。这是为了避免一个含有烂俗名字的目录无意中隐藏了稍后在模块搜索路径中出现的有效模块，比如 string。最简单的情况下，只需要一个空的 `__init__.py` 文件即可。当然它也可以执行包的初始化代码，或者 `__all__` 变量:


> 执行 from package import * 时，如果包中的 __init__.py 代码定义了一个名为 __all__ 的列表，就会按照列表中给出的模块名进行导入。新版本的包发布时作者可以任意更新这个列表。如果包作者不想 import * 的时候导入他们的包中所有模块，那么也可能会决定不支持它(import *)。

###包内引用
如果包中使用了子包结构，可以按绝对位置从相邻的包中引入子模块。
	

##类

一般来说，实例变量用于对每一个实例都是唯一的数据，类变量用于类的所有实例共享的属性和方法。因此， 可变对象，例如列表和字典，的共享数据可能带来意外的效果。	

数据属性会覆盖同名的方法属性。为了避免意外的名称冲突，这在大型程序中是极难发现的 Bug，使用一些约定来减少冲突的机会是明智的。可能的约定包括：大写方法名称的首字母，使用一个唯一的小字符串(也许只是一个下划线)作为数据属性名称的前缀，或者方法使用动词而数据属性使用名词。


##Python标准库概览I

###操作系统接口--os
os 模块提供了很多与操作系统交互的函数：

###文件通配符--glob
glob 模块提供了一个函数用于从目录通配符搜索中生成文件列表

###命令行参数--sys
通用工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量

sys 还有 stdin， stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息

###字符串正则匹配--re
re 模块为高级字符串处理提供了正则表达式工具

###数学--math， random
math 模块为浮点运算提供了对底层 C 函数库的访问

random 提供了生成随机数的工具

###互联网访问
有几个模块用于访问互联网以及处理网络通信协议。其中最简单的两个是用于处理从 urls 接收的数据的 urllib2 以及用于发送电子邮件的 smtplib


###日期和时间--datetime
datetime 模块为日期和时间处理同时提供了简单和复杂的方法。支持日期和时间算法的同时，实现的重点放在更有效的处理和格式化输出。该模块还支持时区处理


###数据压缩
以下模块直接支持通用的数据打包和压缩格式：zlib，gzip，bz2，zipfile 以及 tarfile

###性能度量
有些用户对了解解决同一问题的不同方法之间的性能差异很感兴趣。Python 提供了一个度量工具，为这些问题提供了直接答案。

相对于 timeit 的细粒度，profile 和 pstats 模块提供了针对更大代码块的时间度量工具。

###质量控制
开发高质量软件的方法之一是为每一个函数开发测试代码，并且在开发过程中经常进行测试。

doctest 模块提供了一个工具，扫描模块并根据程序中内嵌的文档字符串执行测试。测试构造如同简单的将它的输出结果剪切并粘贴到文档字符串中。

unittest 模块不像 doctest 模块那么容易使用，不过它可以在一个独立的文件里提供一个更全面的测试集

###其他

* xmlrpclib 和 SimpleXMLRPCServer 模块让远程过程调用变得轻而易举。

尽管模块有这样的名字，用户无需拥有XML的知识或处理 XML。

* email 包是一个管理邮件信息的库，包括MIME和其它基于 RFC2822 的信息文档。

不同于实际发送和接收信息的 smtplib 和 poplib 模块，email 包包含一个构造或解析复杂消息结构(包括附件)及实现互联网编码和头协议的完整工具集。

* xml.dom 和 xml.sax 包为流行的信息交换格式提供了强大的支持。

* 同样，csv 模块支持在通用数据库格式中直接读写。综合起来，这些模块和包大大简化了 Python 应用程序和其它工具之间的数据交换。

* 国际化由 gettext， locale 和 codecs 包支持。

##Python标准库概览II

###输出格式
repr 模块为大型的或深度嵌套的容器缩写显示提供了 repr() 函数的一个定制版本。

pprint 模块给老手提供了一种解释器可读的方式深入控制内置和用户自定义对象的打印。当输出超过一行的时候，“美化打印(pretty printer)”添加断行和标识符，使得数据结构显示的更清晰。

textwrap 模块格式化文本段落以适应设定的屏宽。

locale 模块按访问预定好的国家信息数据库。locale 的格式化函数属性集提供了一个直接方式以分组标示格式化数字。

###模板
string 提供了一个灵活多变的模版类 Template ，使用它最终用户可以简单地进行编辑。这使用户可以在不进行改变的情况下定制他们的应用程序。

###使用二进制数据记录布局
struct 模块为使用变长的二进制记录格式提供了 pack() 和 unpack() 函数。

###多线程
线程是一个分离无顺序依赖关系任务的技术。在某些任务运行于后台的时候应用程序会变得迟缓，线程可以提升其速度。一个有关的用途是在 I/O 的同时其它线程可以并行计算。

多线程应用程序的主要挑战是协调线程，诸如线程间共享数据或其它资源。为了达到那个目的，线程模块提供了许多同步化的原生支持，包括：锁，事件，条件变量和信号灯。

尽管这些工具很强大，微小的设计错误也可能造成难以挽回的故障。因此，任务协调的首选方法是把对一个资源的所有访问集中在一个单独的线程中，然后使用 Queue 模块用那个线程服务其他线程的请求。为内部线程通信和协调而使用 Queue.Queue 对象的应用程序更易于设计，更可读，并且更可靠。

###日志
logging 模块提供了完整和灵活的日志系统。它最简单的用法是记录信息并发送到一个文件或 sys.stderr。

###弱引用
Python 自动进行内存管理(对大多数的对象进行引用计数和垃圾回收 garbage collection 以循环利用)在最后一个引用消失后，内存会很快释放。

这个工作方式对大多数应用程序工作良好，但是偶尔会需要跟踪对象来做一些事。不幸的是，仅仅为跟踪它们创建引用也会使其长期存在。weakref 模块提供了不用创建引用的跟踪对象工具，一旦对象不再存在，它自动从弱引用表上删除并触发回调。典型的应用包括捕获难以构造的对象。

###列表工具

array 模块提供了一个类似列表的 array() 对象，它仅仅是存储数据，更为紧凑。

collections 模块提供了类似列表的 deque() 对象，它从左边添加(append)和弹出(pop)更快，但是在内部查询更慢。这些对象更适用于队列实现和广度优先的树搜索。

heapq 提供了基于正规链表的堆实现。最小的值总是保持在 0 点。这在希望循环访问最小元素但是不想执行完整堆排序的时候非常有用。


###十进制浮点数算法
decimal 模块提供了一个 Decimal 数据类型用于浮点数计算。相比内置的二进制浮点数实现 float，这个类型有助于：

* 金融应用和其它需要精确十进制表达的场合，
* 控制精度，
* 控制舍入以适应法律或者规定要求，
* 确保十进制数位精度，
* 用户希望计算结果与手算相符的场合。

高精度使 Decimal 可以执行二进制浮点数无法进行的模运算和等值测试。decimal 提供了必须的高精度算法。












