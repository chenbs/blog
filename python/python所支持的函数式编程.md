#Python所支持的函数式编程

##函数式编程定义

	"函数式编程"是一种"编程范式"（programming paradigm），将计算机运算看做是数学中函数的计算，并且不修改状态以及变量。
	
##Python中函数编程相关理论

* lambda
* 内建函数式编程函数：map, filter, reduce, zip
* 闭包
* 偏函数
* 迭代器
* 生成器	


##lambda
	
	lambda是匿名函数，没有函数名，在闭包里和map reduce中很好用。
		
语法：

	lambda args: expression
	举例:
	lambda_add = lambda x, y: x + y		
**使用lambda可以编写偶尔为之的、简单的、可预见不会被修改的匿名函数。**


##内建函数map, filter, reduec, zip等

###map(function, iterable, ...) 
map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：

	>>> a=map(lambda x:x*2,[1,2,3])  
	>>> list(a)  
	[2, 4, 6]  
	
###reduce(function, iterable[, initializer]) 
reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：

	>>> functools.reduce(lambda x,y:x*y,range(1,4))  
	6  

###filter(function, iterable) 
这个函数的功能是过滤出iterable中所有以元素自身作为参数调用function时返回True或bool(返回值)为True的元素并以列表返回	
###zip(iterable1, iterable2, ...) 
这个函数返回一个列表，每个元素都是一个元组，包含(iterable1[n], iterable2[n], ...)。 如果参数的长度不一致，将在最短的序列结束时结束；如果不提供参数，将返回空列表。


##闭包

	闭包是一类特殊的函数。如果一个函数定义在另一个函数的作用域中，
	并且函数中引用了外部函数的局部变量，那么这个函数就是一个闭包。
	
	由于使用了函数体外定义的变量，看起来闭包似乎违反了函数式风格的规则,
	即不依赖外部状态。但是由于闭包绑定的是外部函数的局部变量，
	而一旦离开外部函数作用域，这些局部变量将无法再从外部访问；
	另外闭包还有一个重要的特性，每次执行至闭包定义处时都会构造一个新的闭包，
	这个特性使得旧的闭包绑定的变量不会随第二次调用外部函数而更改。
	所以闭包实际上不会被外部状态影响，完全符合函数式风格的要求。	
	
	所以可以使用外部作用域内的变量，但不是全局变量。
	一次创建外部函数，则多次调用内部函数时外部作用域内的变量还是有效的；
	多次运行外部函数，则会重新创建闭包，原来外部变量的值也不会受到影响。比如：
	
	>>> def funA():  
	...     x=0  
	...     def funB():  
	...             nonlocal x  
	...             x+=1  
	...             print(x)  
	...     return funB  
	...   
	>>> a=funA()  
	>>> a()  
	1  
	>>> a()  
	2  
	>>> a()  
	3  

##偏函数

通过为已经存在的某个函数指定数个参数，生成一个新的函数，这个函数只需要传入剩余未指定的参数就能实现原函数的全部功能，这被称为偏函数。Python内置的functools模块提供了一个函数partial，可以为任意函数生成偏函数：

	functools.partial(func[, *args][, **keywords])
	
**需要指定要生成偏函数的函数、并且指定数个参数或者命名参数，然后partial将返回这个偏函数；不过严格的说partial返回的不是函数，而是一个像函数一样可直接调用的对象	。**	


##迭代器

###迭代器(Iterator)概述
**迭代器是访问集合内元素的一种方式。**迭代器对象从集合的第一个元素开始访问，直到所有的元素都被访问一遍后结束。

**迭代器不能回退，只能往前进行迭代。**这并不是什么很大的缺点，因为人们几乎不需要在迭代途中进行回退操作。

**迭代器也不是线程安全的**，在多线程环境中对可变集合使用迭代器是一个危险的操作。但如果小心谨慎，或者干脆贯彻函数式思想坚持使用不可变的集合，那这也不是什么大问题。

对于原生支持随机访问的数据结构（如tuple、list），迭代器和经典for循环的索引访问相比并无优势，反而丢失了索引值（可以使用内建函数enumerate()找回这个索引值，这是后话）。但对于无法随机访问的数据结构（比如set）而言，迭代器是唯一的访问元素的方式。

**迭代器的另一个优点就是它不要求你事先准备好整个迭代过程中所有的元素。**迭代器仅仅在迭代至某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的集合，比如几个G的文件，或是斐波那契数列等等。这个特点被称为延迟计算或惰性求值(Lazy evaluation)。

迭代器更大的功劳是提供了一个统一的访问集合的接口。**只要是实现了\_\_iter\_\_()方法的对象，就可以使用迭代器进行访问**。

###迭代器内建函数

* next()
* hasnext()


###通过enumerate获取迭代器索引
使用迭代器的循环可以避开索引，但有时候我们还是需要索引来进行一些操作的。这时候内建函数enumerate就派上用场咯，它能在iter函数的结果前加上索引，以元组返回，用起来就像这样：

	for idx, ele in enumerate(lst):
  		print idx, ele
  		
  		

###生成器表达式(Generator expression)和列表解析(List Comprehension)

	(x+1 for x in lst) #生成器表达式，返回迭代器。外部的括号可在用于参数时省略。 
	[x+1 for x in lst] #列表解析，返回list

由于返回迭代器时，并不是在一开始就计算所有的元素，这样能得到更多的灵活性并且可以避开很多不必要的计算，*所以除非你明确希望返回列表，否则应该始终使用生成器表达式。*

也可以为列表解析提供if子句进行筛选：
	
	(x+1 for x in lst if x!=0)
或者提供多条for子句进行嵌套循环，嵌套次序就是for子句的顺序：

	((x, y) for x in range(3) for y in range(x))

误区：

	第一个问题是，因为对元素应用的动作太复杂，不能用一个表达式写出来，
	所以不使用列表解析。这是典型的思想没有转变的例子，
	如果我们将动作封装成函数，那不就是一个表达式了么？
	
	第二个问题是，因为if子句里的条件需要计算，同时结果也需要进行同样的计算，不希望计算两遍。
	
**列表解析可以替代绝大多数需要用到map和filter的场合。**	

##生成器(generator)

###生成器简介

生成器就是一种迭代器。生成器拥有next方法并且行为与迭代器完全相同，这意味着生成器也可以用于Python的for循环中。另外，对于生成器的特殊语法支持使得编写一个生成器比自定义一个常规的迭代器要简单不少，所以生成器也是最常用到的特性之一。

###生成器特性

* 调用生成器函数将返回一个生成器；* 
* 第一次调用生成器的next方法时，生成器才开始执行生成器函数（而不是构建生成器时），直到遇到yield时暂停执行（挂起），并且yield的参数将作为此次next方法的返回值；
* 之后每次调用生成器的next方法，生成器将从上次暂停执行的位置恢复执行生成器函数，直到再次遇到yield时暂停，并且同样的，yield的参数将作为next方法的返回值；
* 如果当调用next方法时生成器函数结束（遇到空的return语句或是到达函数体末尾），则这次next方法的调用将抛出StopIteration异常（即for循环的终止条件）；
* 生成器函数在每次暂停执行时，函数体内的所有变量都将被封存(freeze)在生成器中，并将在恢复执行时还原，并且类似于闭包，即使是同一个生成器函数返回的生成器，封存的变量也是互相独立的。

###举例

	>>> def fibonacci():
	...   a = b = 1
	...   yield a
	...   yield b
	...   while True:
	...     a, b = b, a+b
	...     yield b
	...
	>>> for num in fibonacci():
	...   if num > 100: break
	...   print num,
	...
	1 1 2 3 5 8 13 21 34 55 89

看到while True可别太吃惊，因为生成器可以挂起，所以是延迟计算的，无限循环并没有关系。这个例子中我们定义了一个生成器用于获取斐波那契数列。


##参考文章

<http://www.ruanyifeng.com/blog/2012/04/functional_programming.html>
<http://blog.csdn.net/littlethunder/article/details/17652449>
<http://www.cnblogs.com/huxi/archive/2011/06/18/2084316.html>
<http://www.cnblogs.com/huxi/archive/2011/06/24/2089358.html>
<http://www.cnblogs.com/huxi/archive/2011/07/01/2095931.html>
<http://www.cnblogs.com/huxi/archive/2011/07/14/2106863.html>	