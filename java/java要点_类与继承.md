title: java要点_类与继承
date: 2016-05-31 22:13:00
tags:
- java

# java要点_类与继承

## 类知识点

* 类文件是以.java为后缀的代码文件，在每个类文件中`最多只允许出现一个public类`，当有public类的时候，类文件的名称必须和`public类同名`，若不存在public，则类文件的名称可以为任意的名称（当然以数字开头的名称是不允许的）。

* 类内部，对于成员变量，如果在定义的时候没有进行显示的赋值初始化，则Java会保证类的每个成员变量都得到恰当的初始化：

	* 对于  char、short、byte、int、long、float、double等基本数据类型的变量来说会默认初始化为0（boolean变量默认会被初始化为false）
	* 引用类型的变量，会默认初始化为null
	
* 	没有显示地定义构造器，则编译器会自动创建一个无参构造器，但是要记住一点，如果显示地定义了构造器，编译器就不会自动添加构造器。注意，`所有的构造器默认为static的`

* 类是`按需加载`，只有当需要用到这个类的时候，才会加载这个类，并且`只加载一次`

* `类初始化顺序`

	* 当程序执行时，需要生成某个类的对象，Java执行引擎会先检查是否加载了这个类，如果没有加载，则先执行类的加载再生成对象，如果已经加载，则直接生成对象（`使用时加载`）
	
	* `static在类加载过程中按代码定义顺序初始化`：
		
		* 类的`加载过程中`，`类的static成员变量`会被初始化
		* 如果类中有static语句块，则会执行static语句块
		* static成员变量和static语句块的执行顺序同代码中的顺序一致
		
* 在`生成对象的过程中`，会`先初始化对象的成员变量`，然后再执行构造器。也就是说`类中的所有变量`会在任何方法（包括构造器）调用之前得到初始化，即使变量散布于方法定义之间

* `类初始话小结：`第一次使用时，才初始加载类，首先按照代码定义顺序加载`static变量`，然后生成对象，并优先加载类中定义的变量，最后执行初始化函数

## 继承

* java中使用`extends`关键字来表示继承关系。如果没有明确指出要继承的类，就总是隐式地从根类`Object`进行继承。在java中，只允许`单继承`

* 如果两个类存在继承关系，则子类会`自动继承父类`的方法和变量，在子类中可以调用父类的方法和变量	
* 子类继承父类的成员变量：

	* 继承父类的`public`和`protected`成员变量；不能够继承父类的private成员变量
	* 对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承
	* 子类的成员变量会`隐藏掉`父类的`同名成员变量`，可以使用`super`关键字来访问父类中同名成员变量
	
* `覆盖`只针对`非静态方法`（终态方法不能被继承，所以就存在覆盖一说了），而`隐藏`是针对`成员变量`和`静态方法`的。

	这2者之间的区别是：`覆盖受RTTI约束`（Runtime type  identification）的，而隐藏却不受该约束。也就是说只有`覆盖方法才会进行动态绑定`，而`隐藏不会发生动态绑定`的。在Java中，除了`static方法`和`final方法`，其他所有的方法都是动态绑定	
	
* 子类继承父类的方法

	* 能够继承父类的public和protected成员方法；不能够继承父类的private成员方法
	* 对于父类的包访问权限成员方法，如果子类和父类在同一个包下，则子类能够继承
	* 子类的成员方法会`覆盖`掉父类的`同名成员方法`，可以使用`super`关键字来访问父类中同名成员方法
	
	**注意：隐藏和覆盖是不同的。隐藏是针对成员变量和静态方法的，而覆盖是针对普通方法的。	**
	
	
* 构造器

	* 子类是不能够继承父类的构造器
	* 如果父类的构造器都是`带有参数`的，则必须在子类的构造器中通过`super`关键字`显式地`调用父类的构造器并配以适当的参数，并且必须是`第一条语句`
	* 如果父类`存在无参构造器`，则在子类的构造器中不需要显式调用
	
* super

	* `super.成员变量`和`super.成员方法`：主要用来在子类中调用父类的同名成员变量或者方法
	* `super(parameter1,parameter2....)`：用在子类的构造器中显示地调用父类的构造器	

* 父类的构造器调用以及初始化过程一定`在子类的前面`	
	




	
		




## 参考

* [Java：类与继承](http://www.cnblogs.com/dolphin0520/p/3803432.html)