#多线程--多生产者多消费者

1. *while进行标记判断,解决线程获取执行权后，是否要运行。对应的，if判断标记，只有一次，会导致不该运行的线程运行了，出现数据错误的情况*。否则可能由于没进行判断，唤醒本方的线程，导致生产出来新的产品，而旧的没有被消费，或者重复消费。
2. *使用notifyAll，解决了本方线程一定会唤醒对方线程。对应的，notify只能唤醒一个线程，如果本方唤醒了本方的线程，没有意义，而且由于while判断标记notify会导致死锁*。否则由于notify唤醒本方的线程，导致所有线程都进行wait，发生死锁。
3. 但是notifyAll会导致不该唤醒的线程被唤醒，有效率问题。

4. jdk1.5之后，将同步和锁封装成了对象，并将隐士方式定义到了该对象中，将隐式动作变成了显式动作。lock接口。将try...finally和lock





