#多线程--多生产者多消费者

1. *while进行标记判断,解决线程获取执行权后，是否要运行。对应的，if判断标记，只有一次，会导致不该运行的线程运行了，出现数据错误的情况*。否则可能由于没进行判断，唤醒本方的线程，导致生产出来新的产品，而旧的没有被消费，或者重复消费。

2. *使用notifyAll，解决了本方线程一定会唤醒对方线程。对应的，notify只能唤醒一个线程，如果本方唤醒了本方的线程，没有意义，而且由于while判断标记notify会导致死锁*。否则由于notify唤醒本方的线程，导致所有线程都进行wait，发生死锁。


3. 但是notifyAll会导致不该唤醒的线程被唤醒，有效率问题。

4. jdk1.5之后，将同步和锁封装成了对象，并将隐士方式定义到了该对象中，将隐式动作变成了显式动作。lock接口。将try...finally和lock

5. lock接口。将监视器实现为Condition接口，synchronized实现为lock接口。这样就可以实现两个condition，一组监视生产者，一组实现消费者，这样就可以不需要notifyAll，只需要调用对方的condition唤醒对方即可。

6. Lock接口：出现替代了同步代码块或者同步函数。将同步的隐士锁操作变成显示锁操作，同时更为灵活。可以一个锁上加上多组监视器。lock(), unlock()

7. Condition接口：出现替代了Object中的wait，notify，notifyAll。将这些监视器方法单独进行了封装，可以任意锁进行组合。await()，signal(), signalAll()












