title: es进阶(2)
date: 2016-01-28 15:56:25
tags:
- es
- elk

# es进阶(2)

## 分布式搜索

### 分布式搜索的执行方式

一个CRUD操作只处理一个单独的文档。文档的唯一性由_index, _type和routing-value（通常默认是该文档的_id）的组合来确定。这意味着我们可以准确知道集群中的哪个分片持有这个文档。

由于不知道哪个文档会匹配查询（文档可能存放在集群中的任意分片上），所以搜索需要一个更复杂的模型。一个搜索不得不通过查询每一个我们感兴趣的索引的分片副本，来看是否含有任何匹配的文档。

但是，找到所有匹配的文档只完成了这件事的一半。在搜索（search）API返回一页结果前，来自多个分片的结果必须被组合放到一个有序列表中。因此，搜索的执行过程分两个阶段，称为查询然后取回（query then fetch）。	

### 查询阶段

在初始化**查询阶段（query phase）**，查询被向索引中的每个分片副本（原本或副本）**广播**。每个分片在本地执行搜索并且建立了匹配document的**优先队列（priority queue）**。

### 取回阶段

查询阶段辨别出那些满足搜索请求的document，但我们仍然需要取回那些document本身。这就是取回阶段的工作。

#### 深分页

### 搜索选项

一些查询字符串（query-string）可选参数能够影响搜索过程。

* preference（偏爱）
* timeout（超时）
* routing（路由选择）
* search_type（搜索类型）

### 扫描和滚屏

**scan（扫描）**搜索类型是和**scroll（滚屏）API**一起使用来从Elasticsearch里高效地取回巨大数量的结果而不需要付出深分页的代价。

* scroll（滚屏）

	一个滚屏搜索允许我们做一个初始阶段搜索并且持续批量从Elasticsearch里拉取结果直到没有结果剩下。这有点像传统数据库里的cursors（游标）。
	
* scan（扫描）

	深度分页代价最高的部分是对结果的全局排序，但如果禁用排序，就能以很低的代价获得全部返回结果。为达成这个目的，可以采用scan（扫描）搜索模式。扫描模式让Elasticsearch不排序，只要分片里还有结果可以返回，就返回一批结果。
	
为了使用**scan-and-scroll（扫描和滚屏）**，需要执行一个搜索请求，将search_type 设置成scan，并且传递一个scroll参数来告诉Elasticsearch滚屏应该持续多长时间

	GET /old_index/_search?search_type=scan&scroll=1m
	{
	    "query": { "match_all": {}},
	    "size":  1000
	}		


## 索引管理

*(未完待续)*

## 深入分片

*(未完待续)*


## 结构化搜索

### 查找准确值

#### 用于数字的 **term** 过滤器

这个过滤器旨在处理数字，布尔值，日期，和文本。


#### 用于文本的 **term** 过滤器

对于需要查询的字段，通过设置这个字段为 **not_analyzed** 来告诉 Elasticsearch 它包含一个准确值。

### 查询多个准确值

**terms** 过滤器是 **term** 过滤器的复数版本, 用起来和 term 差不多。

**term 和 terms 是包含操作，而不是相等操作**

**but**: 假如你真的需要完全匹配这种行为，最好是通过添加另一个字段来实现。


### 组合过滤

bool 过滤器是以其他过滤器作为参数的组合过滤器，将它们结合成多种布尔组合。

bool 过滤器由三部分组成：

	{
	   "bool" : {
	      "must" :     [],
	      "should" :   [],
	      "must_not" : [],
	   }
	}
	
* must：所有分句都必须匹配，与 AND 相同。
* must_not：所有分句都必须不匹配，与 NOT 相同。
* should：至少有一个分句匹配，与 OR 相同。

> 嵌套布尔过滤器: 虽然 bool 是一个组合过滤器而且接受子过滤器，需明白它自己仍然只是一个过滤器。这意味着你可以在 bool 过滤器中嵌套 bool 过滤器，让你实现更复杂的布尔逻辑。

### 范围

#### range 过滤器

让你可以根据范围过滤。

既能包含也能排除范围，通过下面的选项：

* gt: > 大于
* lt: < 小于
* gte: >= 大于或等于
* lte: <= 小于或等于

### 处理 Null 值

#### exists 过滤器

第一个利器是 **exists** 过滤器，这个过滤器将返回任何包含这个字段的文档

#### missing 过滤器

**missing** 过滤器本质上是 exists 的反义词：它返回没有特定字段值的文档

有时你需要能区分一个字段是没有值，还是被设置为 null。用上面见到的默认行为无法区分这一点，数据都不存在了。幸运的是，我们可以将明确的 null 值用我们选择的占位符来代替

当指定字符串，数字，布尔值或日期字段的映射时，你可以设置一个 **null_value** 来处理明确的 null 值。没有值的字段仍将被排除在倒排索引外。

当选定一个合适的 **null_value** 时，确保以下几点：

* 它与字段的类型匹配，你不能在 date 类型的字段中使用字符串 null_value
* 它需要能与这个字段可能包含的正常值区分开来，以避免真实值和 null 值混淆

## 全文检索

全文检索最重要的两个方面是：

* 相关度(Relevance)

	根据文档与查询的相关程度对结果集进行排序的能力。相关度可以使用TF/IDF、地理位置相近程度、模糊相似度或其他算法计算。

* 分析(Analysis)

	将一段文本转换为一组唯一的、标准化了的标记(token)，用以(a)创建倒排索引，(b)查询倒排索引。

### 匹配查询

**match**查询是你首先需要接触的查询。它是一个高级查询，意味着match查询知道如何更好的处理全文检索和准确值检索。

#### 多词查询

#### 提高精度

匹配包含任意个数查询关键字的文档可能会得到一些看似不相关的结果，这是一种**霰弹策略(shotgun approach)**。

然而我们可能想得到包含所有查询关键字的文档。换句话说，我们想得到的是匹配'brown AND dog'的文档，而非'brown OR dog'。

match查询接受一个**'operator'**参数，默认值为or。如果要求所有查询关键字都匹配，可以更改参数值为and。

#### 控制精度

match查询有**'minimum_should_match'**参数，参数值表示被视为相关的文档必须匹配的关键词个数。

参数值可以设为整数，也可以设置为百分数。因为不能提前确定用户输入的查询关键词个数，使用百分数也很合理。


### 组合查询

像过滤器一样, 布尔查询接受多个用must, must_not, and should的查询子句。


*(未完待续)*

## 地理坐标点

**地理坐标点（geo-point）** 是指地球表面可以用经纬度描述的一个点。地理坐标点可以用来计算两个坐标位置间的距离，或者判断一个点是否在一个区域中。

地理坐标点不能被动态映射（dynamic mapping）自动检测，而是需要显式声明对应字段类型为 **geo_point**。

*e.g.*

	PUT /attractions
	{
	  "mappings": {
	    "restaurant": {
	      "properties": {
	        "name": {
	          "type": "string"
	        },
	        "location": {
	          "type": "geo_point"
	        }
	      }
	    }
	  }
	}

### 经纬度坐标格式

**location** 被声明为 **geo_point** 后，我们就可以索引包含了经纬度信息的文档了。经纬度信息的形式可以是**字符串，数组或者对象**。

**注意**

> 可能所有人都至少踩过一次这个坑：地理坐标点用字符串形式表示时是经度在前，维度在后（"latitude,longitude"），而数组形式表示时刚好相反，是纬度在前，经度在后（[longitude,latitude]）。+
> 
> 其实，在 Elasticesearch 内部，不管字符串形式还是数组形式，都是经度在前，纬度在后。不过早期为了适配 GeoJSON 的格式规范，调整了数组形式的表示方式。
> 
> 因此，在使用地理位置（geolocation）的路上就出现了这么一个“捕熊器”，专坑那些不了解这个陷阱的使用者。

### 通过地理坐标点过滤

有四种地理坐标点相关的过滤方式可以用来选中或者排除文档：

* geo_bounding_box::找出落在指定矩形框中的坐标点
* geo_distance::找出与指定位置在给定距离内的点
* geo_distance_range::找出与指定点距离在给定最小距离和最大距离之间的点
* geo_polygon::找出落在多边形中的点。这个过滤器使用代价很大。当你觉得自己需要使用它，最好先看看 geo-shapes

所有这些过滤器的工作方式都相似： 把 索引中所有文档（而不仅仅是查询中匹配到的部分文档，见 fielddata-intro）的经纬度信息都载入内存，然后每个过滤器执行一个轻量级的计算去判断当前点是否落在指定区域。

> 提示:
> 
> 地理坐标过滤器使用代价昂贵 —— 所以最好在文档集合尽可能少的场景使用。 你可以先使用那些简单快捷的过滤器，比如 term 或者 range，来过滤掉尽可能多的文档，最后才交给地理坐标过滤器处理。
> 
> 布尔型过滤器（bool filter）会自动帮你做这件事。 它会优先让那些基于“bitset”的简单过滤器(见 filter-caching)来过滤掉尽可能多的文档，然后依次才是地理坐标过滤器或者脚本类的过滤器。

#### 地理坐标盒模型过滤器

你指定一个矩形的 顶部（top）, 底部（bottom）, 左边界（left）, 和 右边界（right）， 然后它只需判断坐标的经度是否在左右边界之间，纬度是否在上下边界之间.

##### 优化盒模型

地理坐标盒模型过滤器不需要把所有坐标点都加载到内存里。 因为它要做的只是简单判断 **纬度** 和 **经度** 坐标数值是否在给定的范围内，所以它可以用倒排索引来做一个**范围（range）**过滤。

要使用这种优化方式，需要把 **geo_point** 字段用 **纬度**（lat）和**经度**（lon）方式表示并分别索引。

	PUT /attractions
	{
	  "mappings": {
	    "restaurant": {
	      "properties": {
	        "name": {
	          "type": "string"
	        },
	        "location": {
	          "type":    "geo_point",
	          "lat_lon": true <1>
	        }
	      }
	    }
	  }
	}
	
#### 地理距离过滤器

地理距离过滤器（geo_distance）以给定位置为圆心画一个圆，来找出那些位置落在其中的文档

#### 地理距离区间过滤器

地理距离过滤器（geo_distance）和地理距离区间过滤器（geo_distance_range）的唯一差别在于后者是一个环状的，它会排除掉落在内圈中的那部分文档。

指定到中心点的距离也可以换一种表示方式： 指定一个最小距离（使用 gt或者gte）和最大距离（使用lt或者lte），就像使用区间（range）过滤器一样。	

#### 缓存地理位置过滤器

因为如下两个原因，地理位置过滤器默认是不被缓存的：

* 地理位置过滤器通常是用于查找用户当前位置附近的东西。但是用户是在移动的，并且没有两个用户的位置完全相同，因此缓存的过滤器基本不会被重复使用到。
* 过滤器是被缓存为比特位集合来表示段（segment）内的文档。假如我们的查询排除了几乎所有文档，只剩一个保存在这个特别的段内。一个未缓存的地理位置过滤器只需要检查这一个文档就行了，但是一个缓存的地理位置过滤器则需要检查所有在段内的文档。

> 缓存对于地理位置过滤器也可以很有效。 假设你的索引里包含了所有美国的宾馆。一个在纽约的用户是不会对旧金山的宾馆感兴趣的。 所以我们可以认为纽约是一个热点（hot spot），然后画一个边框把它和附近的区域围起来。
>
> 如果这个地理盒模型过滤器（geo_bounding_box）被缓存起来，那么当有位于纽约市的用户访问时它就可以被重复使用了。 它可以直接排除国内其它区域的宾馆。然后我们使用未缓存的，更加明确的地理盒模型过滤器（geo_bounding_box）或者地理距离过滤器（geo_distance）来在剩下的结果集中把范围进一步缩小到用户附近

#### 减少内存占用

设置一个压缩的（compressed）数据字段格式并明确指定你的地理坐标点所需的精度。

 
### 按距离排序

检索结果可以按跟指定点的距离排序。

## geohashe

Geohashes 是一种将 经纬度坐标对（lat/lon）编码成字符串的方式。

Geohashes 把整个世界分为32个单元的格子--4行8列--每一个格子都用一个字母或者数字标识。 比如 g 这个单元覆盖了半个格林兰，冰岛的全部和大不列颠的大部分。 每一个单元还可以进一步被分解成新的32个单元，这些单元又可以继续被分解成32个更小的单元，不断重复下去。 gc 这个单元覆盖了爱尔兰和英格兰，gcp覆盖了伦敦的大部分和部分南英格兰， gcpuuz94k是伯明翰宫的入口，精确到了约5米。

换句话说，geohash的长度越长，它的精度就越高。 如果两个geohash有一个共同的前缀，如 gcpuuz，就表示他们挨得很紧。 共同的前缀越长，距离就越近。

但那也就是说，两个刚好相邻的位置，会可能有完全不同的geohash。 一个实例，伦敦的 Millenium Dome 的geohash是 u10hbp， 因为它落在了 u这个大单元里，而紧挨着它东边的最大的单元是 g。

> 地理坐标点可以自动关联到他们对应的 geohash。 需要注意的是，他们会被索引到了**所有（各个层级）**的 geohash 前缀（prefixes）。

#### geohash单元过滤器

geohash单元过滤器做的事情非常简单： 把经纬度坐标位置根据指定精度转换成一个geohash，然后查找落在同一个geohash中的位置--这实在是非常高效的过滤器。

	GET /attractions/restaurant/_search
	{
	  "query": {
	    "filtered": {
	      "filter": {
	        "geohash_cell": {
	          "location": {
	            "lat":  40.718,
	            "lon": -73.983
	          },
	          "precision": "2km" <1>
	        }
	      }
	    }
	  }
	}

由于geohash是一个矩形，对于相邻的点可能会被过滤器排除，为了修正这点，需要告诉过滤器，把周围的单元也包含进来。 通过设置**neighbors** 参数为 **true**：

	GET /attractions/restaurant/_search
	{
	  "query": {
	    "filtered": {
	      "filter": {
	        "geohash_cell": {
	          "location": {
	            "lat":  40.718,
	            "lon": -73.983
	          },
	          "neighbors": true, <1>
	          "precision": "2km"
	        }
	      }
	    }
	  }
	}
	
## 地理位置聚合

虽然地理位置过滤或评分功能很有用，不过更有用得是将信息再地图上呈现给用户。 检索的结果集可能很多而不能将每个点都一一呈现，这时候就可以使用地理位置聚合来把这些位置点分布到更加可控的桶（buckets）里。

有三种聚合器可以作用于 geo_point 类型的字段：

* geo_distance：将文档按以指定中心点为圆心的圆环分组
* geohash_grid：将文档按 geohash 单元分组，以便在地图上呈现
* geo_bounds：返回包含一系列矩形框的经纬坐标对，这些矩形框包含了所有的坐标点。 这种方式对于要在地图上选择一个合适的缩放等级（zoom level）时很实用。	

### 按距离聚合

按距离聚合对于类似“找出距我1公里内的所有pizza店”这样的检索场景很适合。 检索结果需要确实地只返回距离用户1km内的文档，不过我们可以再加上一个“1-2km内的结果集”

*(未完待续)*


## 地理形状

地理形状（geo-shapes）使用一种与地理坐标点完全不同的方法。 我们在计算机屏幕上看到的圆形并不是由完美的连续的线组成的；而是用一个个连续的像素点来画出的一个近似圆。 地理形状的工作方式就与此相似。

复杂的形状 -- 比如 点集，线，多边形，多多变形，中空多边形等 -- 都是通过一个个 geohash单元来画出的。 **这些形状会转化为一个被它所覆盖到的 geohash 集合。**

地理形状有这些用处：判断查询的形状与索引的形状的关系；这些关系可能是以下之一：

* intersects::查询的形状与索引形状有重叠（默认）。
* disjoint::查询的形状与索引的形状完全不重叠。
* within::索引的形状完全被包含在查询形状中。


**地理形状不能用于计算距离、排序、打分以及聚集**

### 映射地理形状

与 geo_point类型的字段相似，地理形状也需要在使用前明确映射：
	
	PUT /attractions
	{
	  "mappings": {
	    "landmark": {
	      "properties": {
	        "name": {
	          "type": "string"
	        },
	        "location": {
	          "type": "geo_shape"
	        }
	      }
	    }
	  }
	}
	
### 索引地理形状

地理形状通过**GeoJSON**来表示，这是一种开放的使用JSON实现的二维形状编码方式。 每个形状包含两个信息：形状类型：point, line, polygon, envelope；一个或多经纬度点集合的数组。	
## 关系

### 应用级别的Join操作

我们可以在应用这一层面（部分的）模仿实现关系数据库中的join操作

### 扁平化你的数据

Elasticsearch 鼓励你在创建索引的时候就 **扁平化（denormalizing）** 你的数据，这样做可以获取最好的搜索性能。在每一篇文档里面冗余一些数据可以避免join操作。

## 嵌套

### 嵌套对象




*(未完待续)*


## 多字段搜索

*(未完待续)*


## 模糊匹配（proximity matching）

*(未完待续)*

## 相关性

*(未完待续)*











