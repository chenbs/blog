title: mysql索引和优化
date: 2016-06-22 23:52:00
tags:
- mysql
- index
- optimization


# mysql索引和优化

## 摘要

MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如`BTree索引`，`哈希索引`，`全文索引`等等。

## 数据结构及算法基础

### 索引的本质

索引是一种数据结构，它帮助MySQL高效获取数据。

数据库查询是数据库的最主要功能之一。

* 最基本的查询算法当然是顺`序查找（linear search）`，`O(n)`
* 二分查找（`binary search`）、二叉树查找（`binary tree search`）、红黑树（`red-black tree`）
* `B-Tree`和`B+Tree`	
	

### BTree、B+Tree和R树

[从B树、B+树、B*树谈到R 树](http://blog.csdn.net/v_july_v/article/details/6530142)

使用`BTree`和`B+Tree`作为MySQL索引因素：

* 磁盘寻道，不想内存随机读取
* 减少磁盘读取次数：`O(h) = O(log_d(N))`，`通常只需3次`
* 局部性原理和磁盘预读

	* 每次读取，都会读取这个位置开始的若干长度。一般为页（page）的整倍数。
	
		页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。
	
	* 数据库系统的设计者巧妙利用了磁盘预读原理，将`一个节点的大小设为等于一个页`，这样每个节点只需要一次I/O就可以完全载入。
	* 每次新建节点时，`直接申请一个页的空间`，这样就保证`一个节点物理上也存储在一个页`里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次`I/O`
	* 通常说来，一个页大小存储一个节点，节点的`出度d`都比较大，一般可达到`>100`。所以`h非常小（通常不超过3）O(h) = O(log_d(N))`
	
## MySQL索引实现

> 了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

* 一般在数据库系统或文件系统中使用的`B+Tree`结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。

	在`B+Tree`的每个`叶子节点`增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的`B+Tree`。做这个优化的目的是为了提高`区间访问`的性能。这也是为什么`索引支持区间索引和 % 号的原因`


### MyISAM索引实现

* `MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址`
* MyISAM`索引文件和数据文件是分离`的，索引文件仅保存数据记录的`地址`
* MyISAM的`索引文件仅仅保存数据记录的地址`。在MyISAM中，主索引和辅助索引（Secondary key）在`结构上没有任何区别`，只是主索引要求key是唯一的，而辅助索引的key可以重复。
* MyISAM的索引方式也叫做`“非聚集”`的，之所以这么称呼是为了与`InnoDB的聚集索引`区分。


### InnoDB索引实现

* InnoDB也使用`B+Tree`作为索引结构，但具体实现方式却与MyISAM截然不同
* 重大区别是`InnoDB的数据文件`本身就是`索引文件`
* 树的叶节点`data域`保存了完整的数据记录, 索引的`key`是数据表的`主键`。这种索引叫做`聚集索引`
* InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有`辅助索引都引用主键作为data域`
* 


### 聚集索引和非聚集索引

从上文中看出：

* MyISAM的`B+Tree`将索引文件和数据文件分离，称为`非聚集索引`
* InnoDB的`B+Tree`数据文件本身就是索引文件，称为`聚集索引`

## 索引使用策略

MySQL的优化主要分为`结构优化（Scheme optimization）`和`查询优化（Query optimization）`。先介绍下联合索引和`explain`。

下面分析用的数据库使用：[MySQL官网的employee](http://dev.mysql.com/doc/employee/en/sakila-structure.html)

### 联合索引

* MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引
* 单列索引可以看成联合索引元素数为1的特例。

### 查询优化神器 - explain命令

explain命令相信大家并不陌生，具体用法和字段含义可以参考官网[explain-output](http://dev.mysql.com/doc/refman/5.5/en/explain-output.html)，这里需要强调rows是核心指标，绝大部分rows小的语句执行一定很快（有例外，下面会讲到）。所以优化语句基本上都是在优化rows。

例子：

	EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title='Senior Engineer' AND from_date='1986-06-26';
	+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+
	| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |
	+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+
	|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |
	+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+
	
查看索引：

	SHOW INDEX FROM employees.titles;	

### 最左前缀原理与相关优化

* 最左前缀简单说：就是按照`where子句中的顺序，从左到右看下每个条件能够匹配几个联合索引中的字段，只要有一个不符合，则右边条件的即使有索引也不会使用索引`

根据最左匹配，可以知道：

* 全列匹配

		EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title='Senior Engineer' AND from_date='1986-06-26';
		+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+
		| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |
		+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+
		|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |
		+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+	
	
	当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。
	
	有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引
	
* 最左前缀匹配	

	当查询条件精确匹配索引的左边连续一个或几个列时，如<emp_no>或<emp_no, title>，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。
	
		EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001';
		+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+
		| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra |
		+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+
		|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |       |
		+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+

* 查询条件用到了索引中列的精确匹配，但是中间某个条件未提供

		EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND from_date='1986-06-26';

	因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date。
	
	`优化`：如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引<emp_no, from_date>，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上（“坑”的列值比较少的情况下）
	
* 查询条件没有指定索引第一列

	
		EXPLAIN SELECT * FROM employees.titles WHERE from_date='1986-06-26';
		
	由于不是最左前缀，索引这样的查询显然用不到索引
	
* 匹配某列的前缀字符串

		EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title LIKE 'Senior%';


	可以用到索引，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀
	
* 范围查询

		EXPLAIN SELECT * FROM employees.titles WHERE emp_no < '10010' and title='Senior Engineer';		
		
	范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引
	
	这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。
	
* 查询条件中含有函数或表达式

	如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引。因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。
	
		EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND left(title, 6)='Senior';
		
	虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以

## 优化	

### 自增字段作为主键

在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。考虑到：

* 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。

	InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。
	
	这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。

	如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置

	此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

	

### 建索引的几大原则

既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。

一般两种情况下不建议建索引：

* 第一种情况是表记录比较少
* 区分度低的列不建索引：`count(distinct col)/count(*)`

如果要建索引，遵循原则：

1. 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配`直到遇到范围查询(>、<、between、like)`就停止匹配，

	比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
	
2. =和in可以乱序

	比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式
	
3. 尽量选择区分度高的列作为索引,区分度的公式是`count(distinct col)/count(*)`，表示字段不重复的比例，比例越大我们扫描的记录数越少

	唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录
	
4. 索引列不能参与计算，保持列“干净”

	比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);
	
5. 尽量的扩展索引，不要新建索引。

	比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可
	
### 慢查询优化基本步骤

0. 先运行看看是否真的很慢，注意设置SQL_NO_CACHE
1. where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
2. explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
3. order by limit 形式的sql语句让排序的表优先查
4. 了解业务方使用场景
5. 加索引时参照建索引的几大原则
6. 观察结果，不符合预期继续从0分析

### 前缀索引

有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。

比如：employees表只有一个索引<emp_no>，那么如果我们想按名字搜索一个人，就只能全表扫描了

如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<first_name>或<first_name, last_name>，看下两个索引的选择性：

* `<first_name>`显然选择性太低，
* `<first_name, last_name>`选择性很好，但是first_name和last_name加起来长度为30

这是可以考虑使用前缀索引，通过分析，发现last_name取4效果就很好了：

	SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees;

	+-------------+
	| Selectivity |
	+-------------+
	|      0.9007 |
	+-------------+
	
因此可以建前缀索引：	

	ALTER TABLE employees.employees ADD INDEX `first_name_last_name4` (first_name, last_name(4));
	
此时再执行一遍按名字查询，比较分析一下与建索引前的结果：

	SHOW PROFILES;
	+----------+------------+---------------------------------------------------------------------------------+
	| Query_ID | Duration   | Query                                                                           |
	+----------+------------+---------------------------------------------------------------------------------+
	|       87 | 0.11941700 | SELECT * FROM employees.employees WHERE first_name='Eric' AND last_name='Anido' |
	|       90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name='Eric' AND last_name='Anido' |
	+----------+------------+---------------------------------------------------------------------------------+
	
* 前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。

	
## SQL联合索引与单一列的索引

* 单一列索引就是指在表的某一列上创建索引
* 联合索引是在多个列上联合创建索引.

联合索引使用结论:

1. 查询条件中出现联合索引第一列,或者全部,则能利用联合索引.
2. 条件列中只要条件相连在一起
3. 查询条件中没有出现联合索引的第一列,而出现联合索引的第二列,或者第三列,都不会利用联合索引查询


单一列索引的应用结论:

1. 只要条件列中出现索引列,无论在什么位置,都能利用索引查询


两者的共同点:

1. 要想利用索引,都要符合SARG标准.
2. 都是为了提高查询速度.
3. 都需要额外的系统开销,磁盘空间.


优缺点比较:

1. 索引所占用空间:单一列索引相对要小.
2. 索引创建时间:单一列索引相对短.
3. 索引对insert,update,delete的影响程序:单一列索引要相对低.
4. 在多条件查询时: 联合索引效率要高.
5. 索引的使用范围: 单一列索引可以出现在 where 条件中的任何位置,而联合索引需要按一定的顺序来写.

### 排序（ORDER BY）相关的索引优化及覆盖索引（Covering index）

## 参考

* [MySQL索引原理及慢查询优化](http://tech.meituan.com/mysql-index.html)
* [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
* [SQL联合索引与单一列的索引](http://blog.csdn.net/shellching/article/details/7655793)